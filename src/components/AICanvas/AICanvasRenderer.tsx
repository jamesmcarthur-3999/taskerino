/**
 * AI Canvas Renderer
 *
 * Dynamically renders a CanvasSpec generated by the AICanvasGenerator.
 * This component interprets the AI's design decisions and renders the appropriate
 * layout, sections, and components.
 */

import React from 'react';
import { motion } from 'framer-motion';
import type { Session, SessionSummary } from '../../types';
import type { CanvasSpec } from '../../services/aiCanvasGenerator';
import { ArtifactTimelineModule } from './modules/ArtifactTimelineModule';
import { ArtifactGalleryModule } from './modules/ArtifactGalleryModule';
import { AchievementCard } from './cards/AchievementCard';
import { BlockerCard } from './cards/BlockerCard';
import { InsightCard } from './cards/InsightCard';
import { TaskCard } from './cards/TaskCard';
import { HeroTimeline } from './heroes/HeroTimeline';
import { HeroSplit } from './heroes/HeroSplit';
import { HeroCelebration } from './heroes/HeroCelebration';
import { HeroFocus } from './heroes/HeroFocus';
import { HeroDiscovery } from './heroes/HeroDiscovery';
import { HeroProblemSolver } from './heroes/HeroProblemSolver';
import { LearningCard } from './cards/LearningCard';
import { BreakthroughCard } from './cards/BreakthroughCard';
import { FlowStateCard } from './cards/FlowStateCard';
import { ContextSwitchCard } from './cards/ContextSwitchCard';
import { ProblemSolutionCard } from './cards/ProblemSolutionCard';
import { getRadiusClass, getGlassClasses } from '../../design-system/theme';
import { Calendar, Clock, Camera, TrendingUp } from 'lucide-react';
import { fadeInVariants, createStaggerVariants } from '../../lib/animations';

/**
 * Helper functions for backward-compatible data access
 */

// Get achievements (enhanced or fallback to flat array)
function getAchievements(summary: SessionSummary): Array<{
  text: string;
  timestamp?: string;
  screenshotIds?: string[];
  importance?: string;
}> {
  // Use enhanced version if available
  if (summary.achievementsEnhanced && summary.achievementsEnhanced.length > 0) {
    return summary.achievementsEnhanced;
  }

  // Fallback to flat array
  return (summary.achievements || []).map(text => ({ text }));
}

// Get blockers (enhanced or fallback to flat array)
function getBlockers(summary: SessionSummary): Array<{
  text: string;
  timestamp?: string;
  screenshotIds?: string[];
  severity?: string;
  status?: string;
  resolution?: string;
}> {
  // Use enhanced version if available
  if (summary.blockersEnhanced && summary.blockersEnhanced.length > 0) {
    return summary.blockersEnhanced;
  }

  // Fallback to flat array
  return (summary.blockers || []).map(text => ({
    text,
    status: 'unresolved' as const
  }));
}

// Get key moments (or empty if not available)
function getKeyMoments(summary: SessionSummary) {
  return summary.keyMoments || [];
}

// Get dynamic insights (or empty if not available)
function getDynamicInsights(summary: SessionSummary) {
  return summary.dynamicInsights || [];
}

// Check if session has temporal data
function hasTemporalData(summary: SessionSummary): boolean {
  return !!(
    summary.achievementsEnhanced?.length ||
    summary.blockersEnhanced?.length ||
    summary.keyMoments?.length
  );
}

/**
 * Extract learning moments from summary data
 */
function extractLearningMoments(summary: SessionSummary) {
  const learnings = [];

  // Extract from dynamic insights
  const insights = getDynamicInsights(summary);
  learnings.push(...insights.filter(i =>
    i.type === 'learning' || i.type === 'discovery'
  ).map(i => ({
    title: i.title,
    description: i.description,
    timestamp: i.timestamp,
    confidence: i.confidence
  })));

  // Extract from key insights tagged as learnings
  // Note: keyInsights type doesn't have tags property yet - this is future-proofing
  // if (summary.keyInsights) {
  //   learnings.push(...summary.keyInsights
  //     .filter(i => i.tags?.includes('learning') || i.tags?.includes('discovery'))
  //     .map(i => ({
  //       title: 'Key Learning',
  //       description: i.insight,
  //       timestamp: i.timestamp
  //     }))
  //   );
  // }

  return learnings;
}

/**
 * Extract breakthrough moments from achievements
 */
function extractBreakthroughs(summary: SessionSummary) {
  const achievements = getAchievements(summary);
  const moments = getKeyMoments(summary);

  const breakthroughs = [];

  // High-importance achievements
  breakthroughs.push(...achievements
    .filter(a => a.importance === 'high' || a.importance === 'critical')
    .map(a => ({
      achievement: a.text,
      timestamp: a.timestamp,
      screenshotIds: a.screenshotIds,
      impact: a.importance
    }))
  );

  // Breakthrough-type key moments
  breakthroughs.push(...moments
    .filter(m => m.type === 'breakthrough' || m.type === 'milestone')
    .map(m => ({
      achievement: m.title,
      description: m.description,
      timestamp: m.timestamp,
      impact: m.impact
    }))
  );

  return breakthroughs;
}

/**
 * Extract problem-solving data from blockers
 */
function extractProblemSolutions(summary: SessionSummary) {
  const blockers = getBlockers(summary);

  return blockers
    .filter(b => b.resolution)
    .map(b => ({
      problem: b.text,
      solution: b.resolution!,
      severity: b.severity,
      timestamp: b.timestamp,
      screenshotIds: b.screenshotIds
    }));
}

/**
 * Detect flow states from temporal patterns
 */
function detectFlowStates(session: Session): Array<{
  startTime: string;
  endTime: string;
  duration: number;
  activity: string;
  intensity: 'high' | 'medium' | 'low';
}> {
  const flowStates: Array<{
    startTime: string;
    endTime: string;
    duration: number;
    activity: string;
    intensity: 'high' | 'medium' | 'low';
  }> = [];

  if (!session.summary) return flowStates;

  // Look for periods with high achievement density
  const achievements = getAchievements(session.summary);
  const moments = getKeyMoments(session.summary);

  // Group achievements by time windows (30-minute intervals)
  const timeWindows = new Map<string, any[]>();

  [...achievements, ...moments].forEach(item => {
    if (!item.timestamp) return;

    const time = new Date(item.timestamp);
    const windowKey = `${time.getHours()}:${Math.floor(time.getMinutes() / 30) * 30}`;

    if (!timeWindows.has(windowKey)) {
      timeWindows.set(windowKey, []);
    }
    timeWindows.get(windowKey)!.push(item);
  });

  // Identify high-activity windows as flow states
  for (const [windowKey, items] of timeWindows.entries()) {
    if (items.length >= 3) { // Threshold for "flow"
      const [hour, minute] = windowKey.split(':').map(Number);
      const startTime = new Date(session.startTime);
      startTime.setHours(hour, minute, 0, 0);

      const endTime = new Date(startTime);
      endTime.setMinutes(endTime.getMinutes() + 30);

      flowStates.push({
        startTime: startTime.toISOString(),
        endTime: endTime.toISOString(),
        duration: 30,
        activity: 'High productivity period',
        intensity: (items.length >= 5 ? 'high' : 'medium') as 'high' | 'medium' | 'low'
      });
    }
  }

  return flowStates;
}

/**
 * Detect context switches from key moments
 */
function detectContextSwitches(summary: SessionSummary) {
  const moments = getKeyMoments(summary);

  return moments
    .filter(m => m.type === 'context_switch' || m.type === 'transition')
    .map(m => ({
      from: m.title,
      to: m.description,
      timestamp: m.timestamp,
      impact: m.impact,
      reason: m.description
    }));
}

/**
 * Analyze session characteristics for hero selection
 */
function analyzeSessionCharacteristics(session: Session) {
  const duration = session.endTime
    ? Math.floor((new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / 60000)
    : 0;

  const summary = session.summary;
  if (!summary) {
    return {
      isDeepWork: false,
      isLearning: false,
      isProblemSolving: false,
      isCelebration: false,
      sessionDuration: duration
    };
  }

  const achievements = getAchievements(summary);
  const blockers = getBlockers(summary);
  const learnings = extractLearningMoments(summary);
  const solutions = extractProblemSolutions(summary);

  // Deep work: Long session with steady progress
  const isDeepWork = duration >= 120 && achievements.length >= 5;

  // Learning: Has learning moments or discovery insights
  const isLearning = learnings.length >= 2;

  // Problem solving: Multiple blockers with resolutions
  const isProblemSolving = solutions.length >= 2;

  // Celebration: High-impact achievements
  const isCelebration = achievements.some(a => a.importance === 'high' || a.importance === 'critical');

  return {
    isDeepWork,
    isLearning,
    isProblemSolving,
    isCelebration,
    sessionDuration: duration,
    achievements,
    blockers,
    learnings,
    solutions
  };
}

interface AICanvasRendererProps {
  session: Session;
  spec: CanvasSpec;
}

/**
 * Main renderer component
 */
export function AICanvasRenderer({ session, spec }: AICanvasRendererProps) {
  const duration = session.endTime
    ? Math.floor((new Date(session.endTime).getTime() - new Date(session.startTime).getTime()) / 60000)
    : 0;

  const stats = {
    duration: `${Math.floor(duration / 60)}h ${duration % 60}m`,
    screenshots: session.screenshots?.length || 0,
    date: new Date(session.startTime).toLocaleDateString(),
    hasAudio: session.audioSegments && session.audioSegments.length > 0,
  };

  const staggerVariants = createStaggerVariants({ staggerChildren: 0.1 });

  return (
    <motion.div
      className="space-y-6 max-w-7xl mx-auto"
      initial="hidden"
      animate="visible"
      variants={staggerVariants}
    >
      {/* Render Hero Section */}
      <HeroSection
        session={session}
        spec={spec}
        stats={stats}
      />

      {/* Render Layout */}
      <LayoutRenderer
        session={session}
        spec={spec}
      />

      {/* AI Attribution Badge */}
      <AIBadge spec={spec} />
    </motion.div>
  );
}

/**
 * Hero Section Renderer
 */
function HeroSection({
  session,
  spec,
  stats,
}: {
  session: Session;
  spec: CanvasSpec;
  stats: any;
}) {
  const { theme, layout } = spec;
  const summary = session.summary;

  // Analyze session characteristics for hero selection
  const characteristics = analyzeSessionCharacteristics(session);

  // NEW: HeroFocus for deep work sessions
  if (characteristics.isDeepWork && summary && characteristics.achievements && characteristics.achievements.length > 0) {
    const focusScore = Math.min(100, (characteristics.achievements.length / (characteristics.sessionDuration / 30)) * 100);

    return (
      <HeroFocus
        taskName={session.name}
        duration={characteristics.sessionDuration}
        achievement={characteristics.achievements[0].text}
        focusScore={focusScore}
        theme={{
          primary: theme.primary,
          secondary: theme.secondary,
        }}
      />
    );
  }

  // NEW: HeroDiscovery for learning sessions
  if (characteristics.isLearning && summary && characteristics.learnings && characteristics.learnings.length > 0) {
    const learnings = characteristics.learnings.map(l => l.title);
    const insights = learnings.map(l => `Learning: ${l}`);

    return (
      <HeroDiscovery
        title={session.name}
        topicsExplored={learnings}
        keyInsights={insights}
        resourcesUsed={session.screenshots?.length || 0}
        duration={characteristics.sessionDuration}
        theme={{
          primary: theme.primary,
          secondary: theme.secondary,
        }}
      />
    );
  }

  // NEW: HeroProblemSolver for problem-solving sessions
  if (characteristics.isProblemSolving && summary && characteristics.solutions && characteristics.solutions.length > 0) {
    const primaryProblem = characteristics.solutions[0].problem;
    const solutionFound = characteristics.solutions.length > 0;
    const breakthroughMoment = solutionFound ? characteristics.solutions[0].solution : undefined;

    return (
      <HeroProblemSolver
        problemStatement={primaryProblem}
        solutionFound={solutionFound}
        approachesTried={characteristics.solutions.length}
        duration={characteristics.sessionDuration}
        breakthroughMoment={breakthroughMoment}
        theme={{
          primary: theme.primary,
          secondary: theme.secondary,
        }}
      />
    );
  }

  // Check canvas spec metadata for session type hints
  if (spec.metadata?.sessionType) {
    const sessionType = spec.metadata.sessionType;

    // Future hero routing based on sessionType
    // if (sessionType === 'deep-work') return <HeroFocus ... />;
    // if (sessionType === 'learning') return <HeroDiscovery ... />;
    // if (sessionType === 'problem-solving') return <HeroProblemSolver ... />;
  }

  // EXISTING: Achievement-focused hero
  if (layout.emphasis === 'achievement-focused' && summary) {
    const achievements = getAchievements(summary);
    if (achievements.length > 0) {
      return (
        <HeroCelebration
          title={session.name}
          achievement={achievements[0].text}
          confetti={spec.theme.mood === 'celebratory'}
          theme={{
            primary: theme.primary,
            secondary: theme.secondary,
            mode: 'light',
            primaryColor: theme.primary,
          }}
        />
      );
    }
  }

  // EXISTING: Story or flow layout hero
  if (layout.type === 'story' || layout.type === 'flow') {
    return (
      <HeroSplit
        title={session.name}
        narrative={summary?.narrative || ''}
        stats={stats}
        theme={{
          primary: theme.primary,
          secondary: theme.secondary,
        }}
        featuredImage={session.screenshots?.[0]?.attachmentId}
      />
    );
  }

  // EXISTING: Default timeline hero
  return (
    <HeroTimeline
      title={session.name}
      narrative={summary?.narrative || ''}
      stats={stats}
      theme={{
        primary: theme.primary,
        secondary: theme.secondary,
      }}
    />
  );
}

/**
 * Layout Renderer - renders sections based on layout type
 */
function LayoutRenderer({
  session,
  spec,
}: {
  session: Session;
  spec: CanvasSpec;
}) {
  const { layout } = spec;

  // Grid layout (2-3 columns)
  if (layout.type === 'grid' || layout.type === 'dashboard') {
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {layout.sections.map((section, idx) => (
          <SectionRenderer
            key={idx}
            section={section}
            session={session}
            spec={spec}
          />
        ))}
      </div>
    );
  }

  // Timeline layout (left timeline, right sidebar)
  if (layout.type === 'timeline') {
    const timelineSections = layout.sections.filter(s =>
      s.type === 'timeline' || s.type === 'gallery' || s.type === 'insights'
    );
    const sidebarSections = layout.sections.filter(s =>
      s.type === 'achievements' || s.type === 'blockers'
    );

    return (
      <div className="grid grid-cols-3 gap-6">
        <div className="col-span-2 space-y-6">
          {timelineSections.map((section, idx) => (
            <SectionRenderer
              key={idx}
              section={section}
              session={session}
              spec={spec}
            />
          ))}
        </div>
        <div className="space-y-6">
          {sidebarSections.map((section, idx) => (
            <SectionRenderer
              key={idx}
              section={section}
              session={session}
              spec={spec}
            />
          ))}
        </div>
      </div>
    );
  }

  // Flow layout (stacked vertical)
  return (
    <div className="space-y-6">
      {layout.sections.map((section, idx) => (
        <SectionRenderer
          key={idx}
          section={section}
          session={session}
          spec={spec}
        />
      ))}
    </div>
  );
}

/**
 * Section Renderer - renders individual sections
 */
function SectionRenderer({
  section,
  session,
  spec,
}: {
  section: any;
  session: Session;
  spec: CanvasSpec;
}) {
  // Timeline section
  if (section.type === 'timeline') {
    // Check if we have enhanced temporal data
    const hasEnhancedData = session.summary ? hasTemporalData(session.summary) : false;

    return (
      <motion.div variants={fadeInVariants}>
        <ArtifactTimelineModule
          session={session}
          variant="vertical"
          theme={{
            mode: 'light',
            primaryColor: spec.theme.primary,
          }}
        />
        {!hasEnhancedData && (
          <p className="text-xs text-gray-500 mt-2 text-center">
            Tip: Re-enrich this session to see temporal timeline
          </p>
        )}
      </motion.div>
    );
  }

  // Gallery section
  if (section.type === 'gallery') {
    return (
      <motion.div variants={fadeInVariants}>
        <ArtifactGalleryModule
          screenshots={session.screenshots || []}
          variant="grid"
          columns={3}
          theme={{
            mode: 'light',
            primaryColor: spec.theme.primary,
          }}
        />
      </motion.div>
    );
  }

  // Achievements section
  if (section.type === 'achievements') {
    if (!session.summary) return null;
    const achievements = getAchievements(session.summary);
    if (achievements.length === 0) return null;

    return (
      <CardSection
        title="Wins"
        icon="🎯"
        gradient="from-green-500 to-emerald-500"
      >
        {achievements.map((achievement, idx) => (
          <AchievementCard
            key={idx}
            achievement={achievement.text}
            timestamp={achievement.timestamp}
            relatedScreenshots={
              achievement.screenshotIds
                ? session.screenshots?.filter(s => achievement.screenshotIds!.includes(s.id))
                : undefined
            }
            theme={{
              mode: 'light',
              primaryColor: spec.theme.primary,
            }}
          />
        ))}
      </CardSection>
    );
  }

  // Blockers section
  if (section.type === 'blockers') {
    if (!session.summary) return null;
    const blockers = getBlockers(session.summary);
    if (blockers.length === 0) return null;

    return (
      <CardSection
        title="Blockers"
        icon="⚠️"
        gradient="from-red-500 to-rose-500"
      >
        {blockers.map((blocker, idx) => (
          <BlockerCard
            key={idx}
            blocker={blocker.text}
            severity={(blocker.severity || 'medium') as 'low' | 'medium' | 'high' | 'critical'}
            timestamp={blocker.timestamp}
            status={blocker.status}
            resolution={blocker.resolution}
            theme={{
              mode: 'light',
              primaryColor: spec.theme.primary,
            }}
          />
        ))}
      </CardSection>
    );
  }

  // Insights section
  if (section.type === 'insights') {
    const insights = session.summary?.keyInsights || [];
    if (insights.length === 0) return null;

    return (
      <CardSection
        title="Key Insights"
        icon="💡"
        gradient="from-amber-500 to-orange-500"
      >
        {insights.slice(0, 3).map((insight, idx) => (
          <InsightCard
            key={idx}
            insight={insight.insight}
            timestamp={insight.timestamp}
            tags={[]} // Could be extended with tags
            theme={{
              mode: 'light',
              primaryColor: spec.theme.primary,
            }}
          />
        ))}
      </CardSection>
    );
  }

  // Key Moments section (EXISTING - enhanced temporal data)
  if (section.type === 'key-moments') {
    if (!session.summary) return null;
    const moments = getKeyMoments(session.summary);
    if (moments.length === 0) return null;

    return (
      <CardSection
        title="Key Moments"
        icon="⚡"
        gradient="from-purple-500 to-indigo-500"
      >
        {moments.map((moment, idx) => (
          <motion.div
            key={idx}
            className={`${getGlassClasses('medium')} ${getRadiusClass('field')} p-4 border-l-4 border-purple-500`}
            variants={fadeInVariants}
          >
            <div className="flex items-start gap-3">
              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-br from-purple-400 to-indigo-600 flex items-center justify-center text-white text-xs">
                {moment.type === 'breakthrough' && '💡'}
                {moment.type === 'transition' && '🔄'}
                {moment.type === 'context_switch' && '↔️'}
                {moment.type === 'milestone' && '🎯'}
                {moment.type === 'decision' && '⚖️'}
              </div>
              <div className="flex-1">
                <div className="font-semibold text-gray-900 mb-1">{moment.title}</div>
                <p className="text-sm text-gray-700">{moment.description}</p>
                {moment.timestamp && (
                  <p className="text-xs text-gray-500 mt-2">
                    {new Date(moment.timestamp).toLocaleTimeString()}
                  </p>
                )}
              </div>
              {moment.impact && (
                <div className={`flex-shrink-0 px-2 py-1 rounded text-xs font-semibold ${
                  moment.impact === 'high' ? 'bg-purple-100 text-purple-700' :
                  moment.impact === 'medium' ? 'bg-blue-100 text-blue-700' :
                  'bg-gray-100 text-gray-700'
                }`}>
                  {moment.impact}
                </div>
              )}
            </div>
          </motion.div>
        ))}
      </CardSection>
    );
  }

  // Dynamic Insights section (EXISTING - enhanced AI insights)
  if (section.type === 'dynamic-insights') {
    if (!session.summary) return null;
    const insights = getDynamicInsights(session.summary);
    if (insights.length === 0) return null;

    return (
      <CardSection
        title="Discoveries"
        icon="✨"
        gradient="from-cyan-500 to-teal-500"
      >
        {insights.map((insight, idx) => (
          <motion.div
            key={idx}
            className={`${getGlassClasses('medium')} ${getRadiusClass('field')} p-4`}
            variants={fadeInVariants}
          >
            <div className="flex items-start gap-3">
              <div className="flex-1">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-xs font-semibold text-cyan-600 uppercase tracking-wide">
                    {insight.type}
                  </span>
                  {insight.confidence && (
                    <span className="text-xs text-gray-500">
                      {Math.round(insight.confidence * 100)}% confident
                    </span>
                  )}
                </div>
                <div className="font-semibold text-gray-900 mb-1">{insight.title}</div>
                <p className="text-sm text-gray-700">{insight.description}</p>
              </div>
            </div>
          </motion.div>
        ))}
      </CardSection>
    );
  }

  // NEW: Learning section
  if (section.type === 'learning') {
    if (!session.summary) return null;
    const learnings = extractLearningMoments(session.summary);
    if (learnings.length === 0) return null;

    return (
      <CardSection
        title="Learnings"
        icon="📚"
        gradient="from-blue-500 to-indigo-500"
      >
        {learnings.map((learning, idx) => (
          <LearningCard
            key={idx}
            discovery={learning.title}
            context={learning.description}
            timestamp={learning.timestamp}
            relatedScreenshots={
              learning.screenshotIds
                ? session.screenshots?.filter(s => learning.screenshotIds!.includes(s.id))
                : undefined
            }
          />
        ))}
      </CardSection>
    );
  }

  // NEW: Breakthrough section
  if (section.type === 'breakthrough') {
    if (!session.summary) return null;
    const breakthroughs = extractBreakthroughs(session.summary);
    if (breakthroughs.length === 0) return null;

    return (
      <CardSection
        title="Breakthroughs"
        icon="🚀"
        gradient="from-yellow-500 to-orange-500"
      >
        {breakthroughs.map((breakthrough, idx) => (
          <BreakthroughCard
            key={idx}
            moment={breakthrough.achievement}
            beforeState={'description' in breakthrough ? breakthrough.description : undefined}
            impact={breakthrough.impact === 'high' || breakthrough.impact === 'medium' || breakthrough.impact === 'low' ? breakthrough.impact : 'medium'}
            timestamp={breakthrough.timestamp}
            relatedScreenshots={
              breakthrough.screenshotIds
                ? session.screenshots?.filter(s => breakthrough.screenshotIds!.includes(s.id))
                : undefined
            }
          />
        ))}
      </CardSection>
    );
  }

  // NEW: Problem-solving section
  if (section.type === 'problem-solving') {
    if (!session.summary) return null;
    const solutions = extractProblemSolutions(session.summary);
    if (solutions.length === 0) return null;

    return (
      <CardSection
        title="Problems Solved"
        icon="🔧"
        gradient="from-orange-500 to-red-500"
      >
        {solutions.map((solution, idx) => (
          <ProblemSolutionCard
            key={idx}
            problem={solution.problem}
            solution={solution.solution}
            difficulty={solution.severity === 'high' || solution.severity === 'critical' ? 'hard' : solution.severity === 'low' ? 'easy' : 'medium'}
            timestamp={solution.timestamp}
            relatedScreenshots={
              solution.screenshotIds
                ? session.screenshots?.filter(s => solution.screenshotIds!.includes(s.id))
                : undefined
            }
          />
        ))}
      </CardSection>
    );
  }

  // NEW: Flow states section
  if (section.type === 'flow-states') {
    const flowStates = detectFlowStates(session);
    if (flowStates.length === 0) return null;

    return (
      <CardSection
        title="Flow States"
        icon="🌊"
        gradient="from-teal-500 to-cyan-500"
      >
        {flowStates.map((flowState, idx) => (
          <FlowStateCard
            key={idx}
            activity={flowState.activity}
            duration={flowState.duration}
            focusScore={flowState.intensity === 'high' ? 90 : flowState.intensity === 'medium' ? 70 : 50}
          />
        ))}
      </CardSection>
    );
  }

  // NEW: Context switches section
  if (section.type === 'context-switches') {
    if (!session.summary) return null;
    const switches = detectContextSwitches(session.summary);
    if (switches.length === 0) return null;

    return (
      <CardSection
        title="Context Switches"
        icon="🔀"
        gradient="from-pink-500 to-purple-500"
      >
        {switches.map((switchData, idx) => (
          <ContextSwitchCard
            key={idx}
            fromTask={switchData.from}
            toTask={switchData.to}
            timestamp={switchData.timestamp}
            impact={switchData.impact === 'high' ? 'disruptive' : switchData.impact === 'low' ? 'productive' : 'neutral'}
            reason={switchData.reason}
          />
        ))}
      </CardSection>
    );
  }

  // Unknown section type - skip
  return null;
}

/**
 * Reusable card section container
 */
function CardSection({
  title,
  icon,
  gradient,
  children,
}: {
  title: string;
  icon: string;
  gradient: string;
  children: React.ReactNode;
}) {
  return (
    <motion.div
      className={`${getGlassClasses('medium')} ${getRadiusClass('card')} p-6 shadow-xl`}
      variants={fadeInVariants}
    >
      <div className="flex items-center gap-3 mb-6">
        <div className={`w-10 h-10 rounded-full bg-gradient-to-br ${gradient} flex items-center justify-center text-white`}>
          <span className="text-xl">{icon}</span>
        </div>
        <h2 className="text-xl font-bold text-gray-900">{title}</h2>
      </div>
      <div className="space-y-3">
        {children}
      </div>
    </motion.div>
  );
}

/**
 * AI Attribution Badge
 */
function AIBadge({ spec }: { spec: CanvasSpec }) {
  return (
    <motion.div
      className="text-center py-4"
      variants={fadeInVariants}
    >
      <div className="inline-flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-purple-500/20 to-pink-500/20 backdrop-blur-sm rounded-full text-sm text-gray-700">
        <strong>AI-Designed Canvas</strong> - Generated with {Math.round(spec.metadata.confidence * 100)}% confidence
        <span className="text-xs text-gray-500 ml-2">
          ({spec.metadata.sessionType} • {spec.theme.mood})
        </span>
      </div>
    </motion.div>
  );
}
